## 一、基础语法篇

### 1、环境介绍

- VS的启动
  1)、双击图标
  2)、敲入 devenv

7、以.cs结尾的文件 我们称之为"类"文件

引用命名空间：
A--ProjectA---顾客类
B--ProjectB---顾客类
C--ProjectC---需要用到A和B的两个顾客类   顾客

被class修饰的我们称之为类

解决方案---项目---类之间的关系
解决方案：一个公司
项目：一个部门
类：员工

.sln：解决方案文件，这个文件中包含着当前这个解决方案的一些信息，我们可以双击打开。
.csproj:项目文件，里面包含着当前这个项目的信息，不允许双击打开

8、两行代码
Console.WriteLine("要输出到控制台的文本");
Console.ReadKey();表示暂停这个程序，等待用户按下任意键继续，并且用户按下的任意键将显示到控制台中。


9、运行程序
1、点击启动键
2、F5

10、注释
1)、注销你写的代码
2)、解释你写的代码

11、c#当中的注释符
1)、单行注释  //
2)、多行注释  /*要注释的内容*/
3)、文档注释  ///

### 2、变量及运算符

1、变量
用来存储数据

1、杨浩然  1个人  开一个单人间  208

2、杨浩然 和一个女同事  一个双人间  104

3、杨浩然 和一个男同事  开了两个单人间  309  308

当开房的人员跟数量还有性别不同的时候，我们在旅馆开的房间是不一样的。

我们在计算机中存储数据的大小、类型不同的时候，我们在计算机中开的房间类型也是不一样的。

50  int
int number;//表示在内存中开辟了一个整数类型的房间，并且我们取名为number
number=50;//表示将50这个整数放到number中


3.14
double d;
d=3.14;


2、声明变量的语法
变量类型 变量名;//声明了一个变量
变量名=值;//给这个变量赋值

=号在这行代码中表示赋值的意思，表示把等号右边的值，赋值给等号左边的变量。

一种更为简单的方法：
变量类型 变量名=值;

90.54
double d=90.54;


张三

3、计算机中各种各样的数据类型
int:表示整数类型，只能存放整数。
double:表示小数类型，既能存储整数也能存储小数
string：能够存储多个文本，可以为空
char：字符类型，能够存储单一的字符，要求 最多最少只能存储1个字符，不能为空
decimal：金钱类型，精度要高于double类型  。

4、变量使用的时候需要注意的地方
变量的使用过程：必须要先声明在赋值最后使用
*注意*：变量不允许重复的声明或者定义。但是可以被重复的赋值。

5、一次性声明多个相同类型的变量

6、
命名规则：
1 必须以“字母”_或@符号开头.--不要以数字开头
2 后面可以跟任意“字母”、数字、下划线.
注意:
1）你起的变量名不要与c#系统中的关键字重复.
2）在c#中,大小写是敏感的.
3)同一个变量名不允许重复定义(先这么认为,不严谨)
4)、变量名唯一能够出现的特殊字符只有下划线

要遵守的两个命名规范：
Camel:骆驼命名规范，要求变量名中首单词的首字母要小写，其余每个单词的首字母都要大写，多用于给变量去命名。
nameJapanStar  highSchoolStudent

Pascal:要求变量名中每个单词的首字母都要大写，多用于给类或者方法命名

JapanHotStar


7、赋值运算符和赋值表达式
=：表示把等号右边的值赋值给等号左边的变量。
int number=10;
由等号连接的表达式我们称之为赋值表达式，每个表达式，我们都认为可以求解出一个定值，
那么，对于赋值表达式而言，等号左边变量的值就是整个赋值表达式的值。

8、+号
如果+号两边有一边是字符串的话，那么此时这个+号就起到连接的作用。
如果+号两边都是数字，而不是字符串，那么此时加号就起到相加的作用。

9、占位符
挖个坑，再填个坑。
占位符需要我们注意的地方：
1)、占位符从{0}开始
2)、你挖了几个坑，就填几个坑，如果你多填了，没有效果，但是如果你少填了，程序抛异常
3)、占位符最终按照填坑的顺序输出


10、我们在向控制台输出的内容的时候，不管你输入的内容是什么类型，当打印到控制台的时候，都是字符串类型。
不管我们在控制台输入的内容是什么类型，当我们接受的时候，都必须要按照字符串类型去处理。

11、c#中的转义符
转义符值得就是 一个'\'加上一个特殊的字符，组成了一个具有特殊意义的字符。
\+":表示一个英文半角的双引号。\表示转义，而不表示字符。
\r\n:表示换行，操作系统支持
\n:表示换行，操作系统不支持
\b:表示一个退格键，\b放到字符串的两边没有效果
\t:表示一个tab键
\\：表示一个\
12、@符号的用法
1)、取消\在字符串中的转移作用，使其单纯的表示为一个\
2)、让代码按照你编译的原格式输出

13、算数运算符
+
-
*
/
%
  //自动类型转换或者隐式类型转换
            //1)、类型必须相兼容 (int和double)
            //2)、必须是小的类型转大的类型
            //int n=10;
            //double d = n;

```php
        //强制类型转换 结果：丢失精度
        //303.6===》303   double---->int
        int result = (int)303.6;
        Console.WriteLine(result);
        Console.ReadKey();
```

14、Convert类型转换
在使用的时候需要注意：
如果要发生类型转换的两个变量的类型不兼容，那么这个时候使用Convert类型转换。
前提：面儿上一定要过的去。
如果转换成功，就成功了，如果失败，则抛异常。

1、算运运算符  ++ --
++；分为前++和后++，不管是前++还是后++，最终的结果都是这个变量的值自身加1.
区别：如果在一个表达式中遇到了++运算符，
如果是前++，则首先这个变量的值自身加一，然后拿着这个加一后的值去参与运算。
如果是后++，则首先拿原值参与运算，运算完成后，自身再加一。



2、复合赋值运算符
+= 
-=
*=
/=
%=

3、在一个表达式当中，如果既有一元运算符也有二元运算符，先算一元运算符。

4、关系运算符
>
><
>=
><=
>==
>!=
>关系运算符用来描述两个事物之间的关系。

由关系运算符连接的表达式我们称之为关系表达式。
关系表达式的结果是bool类型。
bool类型只有两个值，true false


5、逻辑运算符 
&& shift+7
||
!

逻辑与的优先级要高于逻辑或，也就是说，在一个逻辑表达式中，如果既有逻辑与运算符，也有逻辑或运算符，
先算逻辑与运算符。

6、顺序结构、分支结构、选择结构
顺序结构：从上到下，代码一行一行的执行，不会发生跳跃。
分支结构：if结构  if-else结构
选择结构：if else-if  switch-case
循环结构：while  do-while for foreach

7、if结构
语法：
if(关系表达式或者bool类型的值或者逻辑表达式)
{
	代码;
}
执行过程：
 程序执行到if处，首先判断if后面所带的条件的值，如果为true，那么。进入if所带的大括号，执行其中的代码。
 如果为false，则跳过if所带的大括号，继续向下执行。

 执行特点：先判断，再执行，有可能一行代码都不执行。

 8、if-else
 语法：
if(关系表达式或者bool类型的值或者逻辑表达式)
{
	代码;
}
else
{
	
}
执行构成：程序首先判断if所带的小括号中的条件是否成立，如果成立，则执行if所带的大括号中的代码，
执行完成后，跳出if-else结构。
如果条件不成立，则跳过if所带的大括号，去执行else所带的大括号中的代码。

特点：先判断，再执行，最少都要执行一个语句块中的代码
注意：else永远都跟离它最近的那个if配对

9、if else-if：针对多条件的判断  
作用：用来做多条件的区间判断
语法：
	if(条件1)
	{
		代码;
	}
	else if(条件2)
	{
		代码;
	}
	else if(条件3)
	{
		代码;
	}
	else
	{

​	}

	
	执行过程：程序运行到if处，首先判断第一个if所带的小括号中的条件是否成立，如果成立，也就是返回一个true，
	则执行当前if所带的大括号中的代码，执行完成后，退出if else-if结构。
	如果第一个if所带的条件不成立，则继续向下进行判断，如果在判断的过程中，某一个if所带的条件成立了，
	则执行该if所带的代码，执行完成后，跳出if else-if结构。
	如果每一个if所带的条件都不成立，则看该结构中有没有else，如果有else，则执行else中的代码
	，如果没有else，则该if else-if结构什么都不做。

10、try-catch异常捕获
try
{
	可能会出现异常的代码;
	范德萨范德萨范德萨范德萨
	fdsfdsf
	fdsfdsfds
	fdsfds
}
catch
{
	出现异常后要执行的代码;
}
执行过程：当try中的代码出现异常的时候，出现异常的这行代码后面的代码不会被执行。
而是直接跳到catch中执行catch的代码。
使用规律：哪行代码有可能出现异常，就踹他一脚。



11、变量的作用域
能够访问到这个变量的范围。
变量的作用域一般从声明他的那个大括号开始到这个大括号所对应的结束的大括号。

12、如果想要让某些代码在满足某些条件的时候去执行，这个时候我们使用bool类型的变量来解决。

13、swtich-case
作用：用来做多条件的定值判断
语法：
switch(要判断的变量或者表达式)
{
	case 值1:要执行的代码;
	break;
	case 值2:要执行的代码;
	break;
	case 值3:要执行的代码;
	break;
	........
	default:要执行的代码;
	break;
}
执行过程：程序运行到switch处，首先计算switch后面所带的小括号中的变量或者表达式的值，拿着计算出来的
这个结果跟每个case的值进行匹配，一旦匹配成功，则执行该case所带的代码块，
如果跟每个casa所带的值都不匹配，则看当前switch-csae结构中是否有default，如果有default，
则执行default所带的代码块，否则的话，什么都不做
break：跳出switch-case结构。

### 3、循环结构

1、循环结构
while  do-while for foreach

2、while循环
语法：
while(循环条件)
{
	循环体；
}
执行过程：
循环条件：当满足这个条件的时候，才进行循环。循环条件一般可以为bool类型的值或者关系表达式或者逻辑表达式。
程序运行到while处，首先判断while所带的循环条件是否成立，如果成立，也就是为true，则执行大括号中的循环体，
当循环体执行完成一遍后，继续回到循环条件进行判断，如果成立，则执行，如果不成立，则跳出while循环。
每个循环都有那么一行代码，能够改变循环条件，使之终有一天不再成立，如果程序中没有那么一行代码能够改变循环条件，
那么我称之为这种循环叫做死循环。

while(true)
{
	
}

注意：在写while循环的时候，一定要分析出循环体和循环条件。
特点:先判断，再执行，有可能一次都不执行。

3、break
break:
1)、跳出switch-case语句。
2)、跳出循环
break单独放到循环中没意义，一般跟if配合着使用，表示当满足某个条件的时候，跳出循环。


3、do-while循环的语法
do
{
	循环体;
}while(循环条件);
执行过程：首先执行do中的循环体，执行完成后，去判断循环条件是否成立，如果成立，
则继续回到do中执行循环体，如果不成立，则跳出do-while循环。

特点：先执行，再判断，最少执行一遍循环体。

4、程序调试
F11 单步调试 逐语句调试
F10 逐过程
断点调试

1、我们在使用while循环或者do-while循环的时候，
经常会忘记给循环变量自增，为了解决这个问题，我们有了更为简单的一种循环，
叫做for循环，for循环专门处理已知循环次数的循环。

for(表达式1;表达式2;表达式3)
{
	循环体；
}
表达式1：一般为声明一个循环变量，用来记录循环的次数
表达式2：一般为循环条件
表达式3：一般为能够改变循环条件的代码
执行过程：在第一次循环的时候，首先执行表达式1，再执行表达式2，然后跳过表达式3.直接执行循环体，
执行完循环体之后，执行表达式3，执行表达式2，循环体，表达式3，表达式2，循环体。。。。。
知道表达式2不成立之后，跳出for循环。


2、break只能够跳出当前循环，而不能跳出所有循环。
3、int.TryParse();
尝试着将一个字符串转换成int类型，如果转换成功的话，返回一个true，并且将转换成功后的值
赋值给一个int类型的参数，如果转换失败的话，返回一个false，并且给这个int类型的参数赋值为0


4、continue
在循环中，如果遇到break，则跳出当前循环。
如果遇到continue，则立即停止本次循环，回到循环条件进行判断，如果循环条件成立，则继续执行循环。
如果不成立，则跳出循环。
单独把continue放到循环中没有意义，一般也跟着if语句配合着使用。

5、三元表达式
表达式1?表达式2:表达式3;
表达式1一般为一个关系表达式，如果关系表达式1的结果为true，那么表达式2的值就是整个三元表达式的值，
否则，表达式3就是整个三元表达式的值。

要求：表达式2和表达式3的结果类型必须一致，并且也要和整个三元表达式的结果类型一致。

6、常量
语法：
const 常量类型  常量名称=值;


7、枚举
语法：
[public] enum 枚举名
{
	值1,
	值2,
	值3,
	........
}
public:访问修饰符。访问的权限，公开的，公共的，谁都能访问。
enum：表示声明枚举的关键字 
枚举名：必须要Pascal命名规范。每个单词的首字母都要大写。

枚举类型和int类型互相兼容，所以两种类型可以通过强制类型转换的语法互相转换。
枚举类型的值默认是从0开始的。

不管是将字符串类型的数字转换成枚举类型还是将int类型转换成枚举类型，结果都不会抛异常。
但是，如果要转换的字符串，在枚举中，并没有所对应的值，这个时候会抛异常。


8、结构：一次性声明多个不同类型的变量
语法：
[public] struct 结构名
{
	结构成员;
}
字段跟变量有一个本质的区别：字段可以存储多个值，而变量只能存储一个值。

9、数组
数组类型[] 数组名=new 数组类型[数组长度];
注意：数组的长度一旦声明了，就不能再被改变了。

### 4、排序算法

1、冒泡排序
int[] nums={9,8,7,6,5,4,3,2,1,0};    0,1,2,3,4,5,6,7,8,9
第一趟比较：8 7 6 5 4 3 2 1 0 9  交换了9次                 i=0    j=nums.Length-1-0;
第二趟比较：7 6 5 4 3 2 1 0 8 9  交换了9次 比较了 但是没交换 i=1   j=8 j=nums.Length-1-1;
第三趟比较：6 5 4 3 2 1 0 7 8 9  交换了7次 					i=2 j=7 j=nums.Length-1-2
第四趟比较：5 4 3 2 1 0 6 7 8 9  交换了6次                  i=3 j=6 
第五趟比较：4 3 2 1 0 5 6 7 8 9  交换了5次                  i=4 j=5
第六趟比较：3 2 1 0 4 5 6 7 8 9  交换了4次
第七趟比较：2 1 0 3 4 5 6 7 8 9  交换了3次
第八趟比较：1 0 2 3 4 5 6 7 8 9  交换了2次
第九趟比较：0 1 2 3 4 5 6 7 8 9  交换了1次

for(int i=0;i<nums.Length-1;i++)
{
	for(int j=0;j<nums.Length-1-i;j++)
	{
		if(nums[j]>nums[j+1])
		{
			int temp=nums[j];
			nums[j]=nums[j+1];
			nums[j+1]=temp;
		}
	}
}

### 5、函数

2、方法(函数)
语法：
[public] static 返回值类型  方法名([参数列表])
{
	方法体;
}
public:访问修饰符，公开的，公共的
static:表示静态
返回值类型：如果没有返回值，写void
方法名：Pascal，要求每个单词的首字母都要大写。
参数列表：完成这个方法，所必须要提供给这个方法的条件。哪怕方法中不需要参数，小括号也不能省略。

参数：
返回值：

方法的调用：
类名.方法名([参数列表]);


3、return
1)、在方法中返回要返回的值
2)、立即结束当前方法


4、调用者和被调用者的关系
我们在Main()函数中调用Test()函数，
我们管Main()函数叫做调用者，管Test()函数叫做调用者，管Test
被调用者。
如果被调用者想要得到调用者中的值：
1、传递参数
2、声明一个静态的字段，当做"全局变量"使用。

如果调用者想要得到被调用者中的值：
1、写返回值。
形参：形式上的参数，也会在内存中开辟空间。
实参：调用函数的时候传入的参数。
问题：形参和实参的名字必须一样么？
5、在写方法的时候需要注意
1、方法的功能一定要单一。
2、在方法中尽量的避免出现提示用户输入之类的代码。
6、out参数
可以帮助我们在一个方法中返回多个值，不限类型。
使用out参数的时候要求，out参数必须在方法内为其赋值。

1、ref参数
ref参数侧重于将一个变量以参数的形式带到一个方法中进行改变，
改变完成后，再讲改变后的值带出来。
在使用ref参数的时候需要注意：ref参数在方法外必须为其赋值。

2、方法的重载
方法的重载指的是方法的名称相同，但是参数不同。
参数不同：
1)、如果参数的个数相同，那么参数的类型就不能相同。
2)、如果参数的类型相同，那么参数的个数就不能相同。

方法的重载跟返回值没有关系。

3、方法的总结
1、作用：可以让代码重复的使用
2、参数：完成这个方法所必须要的条件
3、返回值：完成方法后，方法返回的结果
4、out参数：可以让方法返回多个值
5、ref参数：侧重于将一个变量带到方法中进行改变，改变完成后，再讲改变后的值带出去。
6、params可变参数：将实参列表中跟可变参数数组类型一样的参数当做是可变参数数组中的元素。
可变参数必须形参列表中的最后一个元素
7、方法的重载：
方法的名称相同，但是参数不同。跟返回值没关系。
参数不同：
1)、如果参数的个数相同，那么参数的类型就不能相同。
2)、如果参数的类型相同，那么参数的个数就不能相同。
8、方法的递归：自己在方法中调用自己。

### 6、面向对象介绍

1、面向过程  面向对象
想吃煎饼
面向过程:拿着钱，从宿舍到煎饼摊。
面向对象：找个对象 帮你做事儿。

面向过程：面向的是这件事儿的过程，强调是做这件事儿的动作。
面向对象：面向的是对象。
用面向过程的思想：将大象塞进冰箱里
把大象塞进冰箱里  软件系统
1、打开冰箱门
2、把大象塞进去 ，亲下大象的屁股
//3、关闭冰箱门

杨浩然 高大  浑身都是肌肉
杨浩然可以自己打开冰箱门
杨浩然自己也可以把大象塞进去，亲下大象的屁股
//杨浩然可以自己关闭冰箱门


苏雷 130cm  30KG
苏蕾踩着凳子打开冰箱门
苏蕾 找杨浩然帮忙把大象塞进冰箱里，亲下大象的屁股
//苏蕾自己踩着凳子关闭冰箱门。

用面向对象的思想：将大象塞进冰箱里
把冰箱提取出来作为对象
1、冰箱门可以被打开
2、大象可以被塞进冰箱里，亲一下屁股
3、冰箱门可以被关闭

杨浩然：冰箱门可以被打开
杨浩然：大象可以被塞进冰箱里，亲一下屁股
杨浩然：冰箱门可以被关闭

去中关村买电脑
1、首先 查要买的电脑的型号和价格
2、做车去中关村
3、跟服务员讨价还价
4、被骗


杨浩然：大牛及神人
面向对象的3大特征:封装、继承、多态

关门
门可以被关闭

我在黑板上画了一个圆
黑板可以被画一个圆

描述杨浩然、苏雷的特征和行为
杨浩然：
姓名：杨浩然
性别：男
年龄：18
身高：180cm
体重：10kg
吃喝拉撒睡 吃喝嫖赌抽

苏雷：
姓名：苏雷
性别：男
年龄：81
身高：120cm
体重：20kg
吃喝拉撒睡 吃喝嫖赌抽

在程序中，我们描述一个对象，描述的是这个对象的属性和方法。

对象是实际存在的，一定是看得见摸得着的。

我们把这些具有相同属性和行为的对象进行进一步的封装，提取出了一个概念"类".

类就是一个模子，确定了对象将会拥有的属性和方法。



1、类的语法
[访问修饰符] class 类名
{
	类的成员;
	//字段、属性、方法
}
访问修饰符：public
类名：Pascal 要求每个单词的首字母都要大写。

2、我们写好了一个类之后，需要创建这个类对象，我们管创建这个类的对象的过程，
称之为类的实例化。
使用关键字 new.

3、类中成员的作用
1)、字段：存储数据

4、类中的成员如果不加访问修饰符，默认是private
private：私有的，只能在类的内部访问，出了这个类之后，就访问不到了。

5、this
this代表当前类的对象


6、类是不占内存的，而对象是占内存的

7、属性的作用就是保护字段，对字段的取值和设值进行限定。

8、字段就是女人，而属性就是男人。


9、三种属性
既有get方法也有set方法的属性我们称之为可读可写属性
只有get方法没有set方法我们称之为只读属性
只有set方法没有get方法我们称之为只写属性

10、
对象创建好后，依次的给对象的每个属性赋值，这个过程我们称之为对象的初始化。

11、构造函数
主要作用就是对 对象进行初始化。
构造函数其实就是一个函数，只不过是一个特殊的函数。
语法：
public 构造函数名()
{
	代码;
}
1、没有返回值，连void也不能写。
2、构造函数的名称必须跟类名一致。

12、调用构造函数
new的作用：
1)、在内存的堆中开辟空间
2)、在开辟的堆空间中创建对象
3)、调用对象的构造函数

13、构造函数的特点
1)、可以重载
2)、类中默认会有一个无参数的构造函数，当你写了一个新的构造函数后，那个默认的无参数的
构造函数就被干掉了。

14、静态和非静态的区别
静态成员需要被static修饰，非静态成员不需要加static。
问题1：在一个非静态类中，是否允许出现静态成员？
答：非静态类中是可以出现静态成员的。
问题2：在非静态函数中，能不能够访问到静态成员？
答：在非静态函数中，既可以访问到非静态成员，也可以访问到静态成员。
问题3：在静态函数中，能不能够访问到非静态成员？
答：静态方法只能够访问到静态成员。
问题4：在静态类中能否出现非静态成员？
答：不可以，在静态类中，只允许出现静态成员。
<!--在调用上，静态和非静态的区别-->
1、在调用实例成员的时候，需要使用对象去调用
2、在调用静态成员的时候，必须使用类名.静态成员名;
3、静态类是不允许创建对象的

什么时候使用静态类，什么时候使用非静态类？
如果你写的类属于工具类，可以考虑写成静态类。
静态的好处：资源共享。
静态类应该越少越好。

15、GC Gargbage Collection
当我们程序结束之后，GC会扫描整个内存，发现，如果有的空间没有被指向，
则马上把这块空间销毁。


16、在一个项目中引用另一个项目的类
1、添加要引用的类所在的项目。
2、引用命名空间

17、访问修饰符
public :公开的，公共的
private：私有的，只能在类的内部访问，出了这个类之后，就访问不到了。
能够修饰类的访问修饰符只有两个：
1)、public
2)、internal：表示只能在当前程序集的内部进行访问，出了这个程序集就访问不到啦。
对于咱们而言，现阶段就将程序集理解为当前项目。

18、字符串
由于字符串的不可变性，所以，当我们需要给一个字符串进行大量的拼接、赋值等操作的时候，
会产生大量的内存垃圾，所以说，这么做是不合算的。
如果你需要对一个字符串进行大量的重复，拼接等操作，我们推荐使用StringBuilder

19、字符串的各种方法
ToCharArray():将字符串转换成char类型的数组
new string(char[] chs):将一个字符数组转换成一个字符串
ToUpper():表示将一个字符串转换成大写形式。
ToLower():表示将一个字符串转换成小写形式。
Equals("要比较的字符串",StringComparison.OrdinalIgnoreCase)：比较字符串，忽略大小写
Split(new char[]{'要分割的字符串'},StringSplitOption.RemoveEmptyEntries):分割字符串，返回一个字符串类型的数组
Substring():截取字符串

1、继承
我们在写类的过程当中，会发现，在多个类当中会存在一些相同的属性和方法。
为了解决这种代码冗余，于是乎，我们使用继承来解决这个问题。

我们把一些类当中所共同具有的属性和方法单独的拿出来封装成一个父类。
然后让其他类去继承这个父类。



如果一个类继承了另一个类，我们管这个类称之为子类，管被继承的那个类称之为父类。
或者 管这类称之为派生类，管被继承的那个类称之为基类。

语法：
:要继承的类

2、一个子类继承了一个父类，那么这个子类继承了父类的什么成员？
字段、属性、方法、构造函数

子类继承了父类的属性和方法。
子类并没有继承父类的私有字段。
子类并没有继承父类的构造函数，而是会默认的调用父类那个无参数的构造函数，
当你在父类中写了一个有参数的构造函数之后，那个默认的无参数的构造函数就被干掉了，
此时子类就调不到那个无参数的构造函数了。
解决办法：
1)、在父类中重新写一个无参数的构造函数。
2)、让子类去显示的调用父类有参数的构造函数。使用关键字:base()


3、继承的两个特性
1、单根性，一个子类只能有一个父类。一个儿子只能有一个爹。
2、传递性，爷爷有的，爹肯定有，爹有的，最终儿子也会有。

4、object类是一切类型的基类

5、new的用法
1)、创建对象
2)、隐藏从父类那里继承过来的成员


6、this的用法
1)、代表当前类的对象
2)、显示的调用自己的构造函数


7、里氏转换
1)、子类可以赋值给父类。
2)、如果这个父类中装的是子类对象，那么可以将这个父类强转为子类对象。

8、两个关键字
is：类型转换  ，如果转换成功，返回一个true，否则返回一个false。
as：类型转换，如果转换成功，则返回对应的对象，如果转换失败，返回一个null。

9、导入命名空间
1、使用快捷键 alt+shift+F10
2、使用鼠标的方式  
10、File类
Exist():判断指定的文件是否存在
Move()：对一个指定的文件进行剪切操作
Copy():对一个指定的文件进行复制操作
Create():创建一个新文件
Delete():删除一个指定的文件

### 7、集合定义

1、集合
集合相对于数组的好处
1)、长度可变
2)、可以添加任意类型的元素
不好的地方：
从集合中取值的时候必须要不停的做类型转换

2、集合的方法
Add():添加单个元素
AddRange()：添加集合
Clear():清空集合中所有的元素
Remove():删除集合中的元素，括号里写谁，集合就删谁
RemoveAt():根据索引去删除集合中的元素
RemoveRange()：删除一定范围内的元素
Insert():向集合的指定位置插入一个元素
InsertRange()：向集合的指定位置插入一个集合
Contains():判断集合中是否包含某个元素
Sort()：升序排列

3、集合的两个属性
Count ：获取这个集合中实际包含的元素个数
Capcity：获取这个集合可以包含的元素个数

4、var推断类型
var可以通过变量的值来推断出来这个变量的类型。


5、Hashtable
在键值对集合中，键一定是唯一的，不能重复的，而值是可以重复的。

6、编码 GB2312---GBK
将字符串以什么样的形式保存为二进制，这个就是编码，UTF-8、ASCII、Unicode等，

产生乱码的原因：
我保存这个文件的时候所采取的编码格式跟我打开的时候所采取的编码格式不一致。


7、文本文件
拖到txt里还能看得懂的是文本文件。

8、绝对路径、相对路径
绝对路径：根据这个文件的路径，直接能在你的电脑上找到。
相对路径：相对于你应用程序的路径。

1、文件流
用来操作大文件
FileStream：用来操作字节的

StreamWriter StreamReader：用来操作字符的

2、由于我们在使用FileStream的过程当中，经常会忘记写Close() Dispose(),
所以微软提供给我们更为简单的方法帮助我们关闭流和释放流所占用的资源。
就是将创建FileStream对象的过程写在using(){}当中

3、装箱、拆箱
装箱：值类型-------->引用类型
拆箱：引用类型------>值类型
我们看两个类型之间是否发生装箱或者拆箱，首先要确定这两个类型之间是否存在继承关系。
如果存在，则有可能会发生拆箱或者装箱，
如果不存在继承关系，则不会发生装箱或者拆箱。
注意：装箱的时候使用什么类型装的箱，拆的时候也得使用对应的类型进行拆箱。(里氏转换)

1、c#中的访问修饰符
public:公开的，公共的
private：私有的，只能在当前类的内部访问
protected：受保护的，只能在当前类的内部以及该类的子类中访问
internal：只能在当前项目中访问
protecte internal:protecte+internal

修饰符类的访问修饰符只有两个：public internal

protecte internal

2、设计模式 简单工厂设计模式

1、接口
语法：
[public] interface 接口名称
{
	接口成员;
}
2、明文保存
123456  123456  

3、MD5这个算法是不可逆的

4、winform窗体应用程序是一种智能的客户端技术。C/S  
通过它，我们可以智能的获取数据和显示数据。、


5、事件

XAML

1、Button 按钮控件
2、TextBox 文本框控件  WordWrap指示是否换行   passwordChar  TextChange()
3、Label 显示文本
4、RadioButton 单选框   Checked 指示是否被选中
5、CheckBox 复选框
6、GroupBox 容器
7、PictureBox  Image 显示的图片的路径 SizeMode图片的布局
8、Timer 每隔指定的时间发生一件事情  Enabled interval 执行事件间隔的时间  Tick
9、ComboBox:dropdownstyle  
10、MDI窗体的设计
11、WebBrower：Url



1、进程类
Process

2、使用控制台打开文件案例
类的设计：
   1、文件类型的父类 CommonFile
属性：存储文件名
方法：打开文件的抽象方法OpenFile(); 
   2、TxtFile
构造函数：在创建TxtFile这个对象的时候，传入文件名
重写父类的抽象方法：OpenFile():根据用户输入的磁盘路径以及文件名。
通过我们的进程类(Process)去打开指定的文件

简单工厂的设计：
写了一个静态方法，根据用户输入的文件名的后缀名，去创建不同的对象。
由于，不晓得用户会输入什么类型的文件，所以在这个方法中返回的是父类类型，
但是，父类里面装的肯定是子类对象。


2、面向对象总复习
1)、类中的成员：字段、属性、方法、构造函数
字段：类中唯一存储数据
属性：保护字段，对字段的取值和赋值进行限定，属性的本质就是两个方法 get() set()
方法：对象的行为
构造函数：初始化对象(给对象的每个属性依次的赋值)，可以有重载。
类当中默认会有一个无参数的构造函数，当你写了一个新的构造函数之后，那个默认的无参数的
就被干掉了。

2)、类写好后，我们需要创建这个类的对象，我们管创建这个类的对象的过程称之为类的实例化。
使用关键字 new。

3)、保护字段的3种方式
1、get()
2、set()
3、构造函数


3、return
1、在方法中返回要返回的值
2、立即结束本次方法的执行


4、new的作用
1、创建对象
1)、在堆中开辟空间
2)、在开辟的堆空间中创建对象
3)、调用对象的构造函数

2、在子类中隐藏从父类那里继承过来的成员

5、this
1、代表当前类的对象
2、显示的调用自己的构造函数


6、base
1、显示的调用父类的构造函数
2、调用父类中的重名方法


7、继承
好处：减少代码的冗余。
子类继承了父类，继承了什么？
子类继承了父类的属性和方法，并没有继承私有字段。
构造函数有没有继承？
子类并没有继承父类的构造函数，而是会去调用父类那个无参数的构造函数。
目的：为了初始化父类，能够让子类调用到父类中的成员。

当你在父类中重新写了有参数的构造函数之后，那个无参数的就被干掉了，
此时，子类调不到了，解决办法：
1、在父类中重新写一个无参数的构造函数
2、在子类中显示的调用父类的构造函数 :base

8、单例模式
目的:只创建同一个对象。
1、将要创建的对象所在的类的构造函数私有化。


9、静态和非静态
1、在一个类中，如果既有静态成员，也有非静态成员，则首先初始化静态成员，并且只初始化一次，
不管你有多少个对象，都只初始化一次。
而我们的非静态成员，有多少个对象，就初始化多少次。

2、在整个项目当中静态成员是资源共享的。

3、静态成员只有在整个项目都结束的时候，才释放资源。


10、里氏转换
1、子类可以赋值给父类(如果有一个地方需要父类作为参数，我们可以给一个子类代替)
2、如果这个父类中装的是子类对象，则可以将这个父类强转为子类对象。

11
is：表示类型转换，如果转换成功返回一个true，否则返回false
as：表示类型转换，如果转换成功，则返回对应的对象，否则返回null

12、访问修饰符
public:公开的公共的，在哪都可以访问到。
internal：只能在当前项目内部访问，在项目的内部，public的权限跟internal是一样的。
private：私有的，只能在当前类的内部访问。
protected ：受保护的，只能在当前类的内部以及该类的子类中访问。
protected internal：
修饰符类的访问修饰符：public internal
修饰符类中的成员的访问修饰符：public private internal protected  protected internal

注意：子类的访问权限不能高于父类的访问权限。
因为子类肯能会暴漏父类的成员。

13、多态
1、虚方法
2、抽象类
3、接口



1、委托就是指向了一个方法

2、XML  HTML  超文本标记语言  <p> <img  <xyz>
xml:可扩展的标记语言 标签
严格区分大小写

HTML:显示网页内容，起到了一个显示的效果
xml：存储数据。小型的数据库
XML文件有且只能有一个跟节点
c#  HTML  CSS  XML  JS  Jq


XML  记事儿本
使用XML存储1本书的信息
<Books>
	<Book>
		<Name>金瓶梅</Name>
		<Price>100</Price>
		<Des>给力！好看！顶！！！</Des>
	</Book>
	<Book>
		<Name>水浒传</Name>
		<price>10</Price>
		<Des>无聊</Des>
	</Book>
</Books>

金瓶梅  100  好看 给力 顶！！！

节点 元素

===========================================================================
播放器项目：
1、在组件中 拖入 windows media player
2、设置这个组件的属性 Url：赋值给一个首歌曲的路径
3、取消播放器的自动播放功能
4、Ctlcontrols：
play():播放音乐
Pause():暂停音乐
Stop():停止音乐
5、通过一个按钮来实现播放器的开始或者暂停
6、点击打开按钮的时候，弹出来一个对话框，我们可以再对话款中选择我们想要播放的音乐文件。
当我们在对话框中点击确定的时候，将我们选中的这些音乐文件的名称加载到ListBox列表中。
7、实现双击播放功能
8、实现上一曲和下一曲
9、静音或者放音  使用Tag属性作为标记。
10、选择音乐文件后，点击播放，直接播放音乐。使用bool类型解决从头开始播放的问题。
11、多选删除
1、将ListBox的SelectionMode属性设置为MultiExtented。
2、获得当前在ListBox中选中项的个数，通过循环去一个一个的删除
3、先删除List泛型集合中的元素，在去删除ListBox列表中的元素
12、自动播放下一曲
播放器有这样的几个状态：
Ready Playing Paused MediaEnded Stop
要让播放器进行下一曲，应该在播放器的状态是 MediaEnded的时候进行下一曲。
13、显示歌词
1、确定当前正在播放的音乐是否有歌词文件
2、使用File.ReadAllLines()拿到每一行的歌词



